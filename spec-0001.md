---
title: "SPEC 1 — Lazy Loading for Submodules"
date: 2020-12-17
draft: true
author:
  - "Stéfan van der Walt <stefanv@berkeley.edu>"
  - "Jon Crall <jon.crall@kitware.com>"
  - "Dan Schult <dschult@colgate.edu>"
discussion: https://discuss.scientific-python.org/t/spec-1-lazy-loading-for-submodules/25
endorsed-by:
---

# Description

Early on, most scientific Python packages explicitly imported their submodules.
For example, you would be able to do:

```python
import scipy as sp

sp.linalg.eig(...)
```

This was convenient: it had the simplicity of a flat namespace, but with the organization of a nested one.
However, there was one drawback: importing submodules, especially large ones, introduced unacceptable slowdowns.

For a while, SciPy had a lazy loading mechanism called `PackageLoader`.
It was eventually dropped, because it failed frequently and in confusing ways—especially when used with interactive prompts.

Thereafter, most libraries stopped importing submodules and relied on documentation to tell users which submodules to import.

Commonly, code now reads:

```python
from scipy import linalg
linalg.eig(...)
```

Since the `linalg` submodule often conflicts with similar instances in other libraries, users also write:

```python
# Invent an arbitrary name for each submodule
import scipy.linalg as sla
sla.eig(...)
```

or

```python
# Import individual functions, making it harder to know where they are from
# later on in code.
from scipy.linalg import eig
eig(...)
```

This SPEC proposes a lazy loading mechanism—targeted at libraries—that avoids import slowdowns and brings back explicit submodule exports, but without slowing down imports.

For example, it allows the following behavior:

```python
import skimage as ski  # cheap operation; does not load submodules

ski.filters  # cheap operation; loads the filters submodule, but not
             # any of its submodules or functions

ski.filters.gaussian(...)  # loads the file in which gaussian is implemented
                           # and calls that function

```

This has several advantages:

1. It exposes a **nested namespace that behaves as a flat namespace**.
   This avoids carefully having to import exactly the right combination of submodules, and allows interactive exploration of the namespace in an interactive terminal.

2. It **avoids having to optimize for import cost**.
   Currently, developers often move imports inside of functions to avoid slowing down importing their module.
   Lazy importing makes imports at any depth in the hierarchy cheap.

3. It provides **direct access to submodules**, avoiding local namespace conflicts.
   Instead of doing `import scipy.linalg as sla` to avoid clobbering a local `linalg`, one can now assign a short name to each library and access its members directly: `import scipy as sp; sp.linalg`.

### Usage

Python 3.7, with [PEP 562](https://www.python.org/dev/peps/pep-0562/), introduces the ability to override module `__getattr__` and `__dir__`.
In combination, these features make it possible to again provide access to submodules, but without incurring performance penalties.

We propose a utility library for easily setting up so-called "lazy imports" so that submodules are only loaded upon accessing them.

As an example, we will show how to set up lazy importing for `skimage.filters`.
In the library's main `__init__.py`, specify which submodules are lazily loaded:

```python
__all__ = [
    ...
    'filters',
    ...
]

from .util.lazy import install_lazy
__getattr__, __dir__, _ = install_lazy(__name__, __all__)
```

Then, in each submodule's `__init__.py` (in this case, `filters/__init__.py`), specify which functions are to be loaded from where:

```python
from ..util import lazy

__getattr__, __dir__, __all__ = lazy.install(
    __name__,
    submodules=['rank']
    submod_attrs={
        '_gaussian': ['gaussian', 'difference_of_gaussians'],
        'edges': ['sobel', 'sobel_h', 'sobel_v',
                  'scharr', 'scharr_h', 'scharr_v',
                  'prewitt', 'prewitt_h', 'prewitt_v',
                  'roberts', 'roberts_pos_diag', 'roberts_neg_diag',
                  'laplace',
                  'farid', 'farid_h', 'farid_v']
    }
)
```

The above would be equivalent to:

```python
from . import rank
from ._gaussian import gaussian, difference_of_gaussians
from .edges import (sobel, sobel_h, sobel_v,
                    scharr, scharr_h, scharr_v,
                    prewitt, prewitt_h, prewitt_v,
                    roberts, roberts_pos_diag, roberts_neg_diag,
                    laplace,
                    farid, farid_h, farid_v)
```

The difference being that the submodule is loaded only once it is accessed:

```python
import skimage
dir(skimage.filters)  # This works as usual
```

Furthermore, the functions inside of the submodule are loaded only
once they are needed:

```python
import skimage

skimage.filters.gaussian(...)  # Lazy load `gaussian` from
                               # `skimage.filters._gaussian`

skimage.filters.rank.mean_bilateral(...)  # Loaded once `rank` is accessed
```

One disadvantage is that erroneous or missing imports no longer fail immediately.
During development and testing, the `EAGER_IMPORT` environment variable can be set to disable lazy loading, so that errors like these can be spotted.

#### External libraries

The `lazy.install_lazy` function is an alternative to setting up package internal imports.
We also provide `lazy.load` so that projects can lazily import external libraries:

```python
linalg = lazy.load('scipy.linalg')  # `linalg` will only be loaded when accessed
```

# Implementation

Currently, a work-in-progress implementation lives in [this pull request to scikit-image](https://github.com/scikit-image/scikit-image/pull/5101)—specifically, inside of `lazy.py`.

At this point, there exists a prototype of lazy loading, and we're showing it to the community to uncover design flaws, discover improvements, and solicit suggestions on APIs.

Once a lazy import interface is implemented, other interesting options become available.
For example, instead of specifying sub-submodules and functions the way we do above, one could do this in YAML files:

```
$ cat skimage/filters/init.yaml

submodules:
- rank

functions:
- _gaussian:
  - gaussian
  - difference_of_gaussians
- edges:
  - sobel
  - sobel_h
  - sobel_v
  - scharr

...
```

Ultimately, we hope that lazy importing will become part of Python itself, but the developers have indicated that this is unlikely in the near future.
In the mean time, we now have the necessary mechanisms to implement it ourselves.

## Core Project Endorsement

<!--
Discuss what it means for a core project to endorse this SPEC.
-->

## Ecosystem Adoption

<!--
Discuss what it means for a project to adopt this SPEC.
-->

# Notes

- The [lazy loading blog post by Brett Cannon](https://snarky.ca/lazy-importing-in-python-3-7/) showed the feasibility of the concept, and informed our design.

- Technical improvements happened around the [scikit-image PR](https://github.com/scikit-image/scikit-image/pull/5101)

- [mkinit](https://github.com/Erotemic/mkinit) is a tool that automates the generation of `__init__.py` files, and supports this lazy loading mechanism.
  See, e.g., [NetworkX PR #4496](https://github.com/networkx/networkx/pull/4496).

- The lazy loading discussion was initiated in [NetworkX PR #4401](https://github.com/networkx/networkx/pull/4401).
