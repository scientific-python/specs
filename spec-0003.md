---
title: "SPEC 3 — Lazy Loading for Submodules"
date: 2020-12-17T18:15:04-08:00
draft: false
author: 'Stefan van der Walt <stefanv@berkeley.edu>'
spec_status: Draft
spec_type: Standard
summary: |
  Recommends lazy loading functionality for an easily-accessible namespace,
  but without compromising performance.
---

## Description

Early on, most scientific Python packages explicitly imported their submodules.  For example, you would be able to do:

```python
import scipy as sp

sp.linalg.eig(...)
```

This was convenient: it had the simplicity of a flat namespace, but with the organization of a nested one.  However, there was one drawback: importing submodules, especially large ones, introduced unacceptable slowdowns.  To address the problem, most libraries stopped importing submodules and relied on documentation to tell users which submodules to import.

Commonly, code now reads:

```python
from scipy import linalg
linalg.eig(...)
```

Since the `linalg` submodule often conflicts with similar instances in other libraries, users also write:

```python
# Invent an arbitrary name for each submodule
import scipy.linalg as sla
sla.eig(...)
```

or

```python
# Import individual functions, making it harder to know where they are from
# later on in code.
from scipy.linalg import eig
eig(...)
```

This SPEC proposes a lazy loading mechanism—targeted at libraries—that
avoids import slowdowns and brings back explicit submodule exports,
but without slowing down imports.

For example, it allows the following behavior:

```python
import skimage as ski  # cheap operation; does not load submodules

ski.filters  # cheap operation; loads the filters submodule, but not
                 # any of its submodules or functions

ski.filters.gaussian(...)  # loads the file in which gaussian is implemented
                           # and calls the function

```

This has several advantages:

1. It exposes a **nested namespace that behaves as a flat namespace**.  This avoids carefully having to import exactly the right combination of submodules, and allows interactive exploration of the namespace in an interactive terminal.

2. It **avoids having to optimize for import cost**.  Currently, developers often move imports inside of functions to avoid slowing down importing their module. Lazy importing makes imports at any depth in the hierarchy cheap.

3. It provides **direct access to submodules**, avoiding local namespace conflicts.  Instead of doing ``import scipy.linalg as sla`` to avoid clobbering a local ``linalg``, one can now assign a short name to each library and access its members directly: ``import scipy as sp; sp.linalg``.

### Usage

Python 3.7, with [PEP 562](https://www.python.org/dev/peps/pep-0562/), introduces the ability to override module `__getattr__` and `__dir__`.  In combination, these features make it possible to again provide access to submodules, but without incurring performance penalties.

We propose a utility library for easily setting up so-called "lazy
imports" so that submodules are only loaded upon accessing them.

As an example, we will show how to set up lazy importing for
`skimage.filters`.  In the library's main `__init__.py`, specify which
submodules are lazily loaded:

```python
__all__ = [
    ...
    'filters',
    ...
]

from .util.lazy import install_lazy
__getattr__, __dir__, _ = install_lazy(__name__, __all__)
```

Then, in each submodule's `__init__.py` (in this case, `filters/__init__.py`), specify which functions are to be loaded from where:

```python
from ..util import lazy

__getattr__, __dir__, __all__ = lazy.install_lazy(
    __name__,
    submodules=['rank']
    submod_funcs={
        '_gaussian': ['gaussian', 'difference_of_gaussians'],
        'edges': ['sobel', 'sobel_h', 'sobel_v',
                  'scharr', 'scharr_h', 'scharr_v',
                  'prewitt', 'prewitt_h', 'prewitt_v',
                  'roberts', 'roberts_pos_diag', 'roberts_neg_diag',
                  'laplace',
                  'farid', 'farid_h', 'farid_v']
    }
)
```

The submodule is loaded only once it is accessed:

```python
import skimage
dir(skimage.filters)
```

Furthermore, the functions inside of the submodule are loaded only once they are needed:

```python
import skimage

skimage.filters.gaussian(...)  # Lazy load `gaussian` from
                               # `skimage.filters._gaussian`

skimage.filters.rank.mean_bilateral(...)  # Loaded once `rank` is accessed
```

## Implementation

Currently, a test implementation lives in [this pull request to scikit-image](https://github.com/scikit-image/scikit-image/pull/5101)—specifically, inside of [`lazy.py`](https://github.com/scikit-image/scikit-image/blob/f5727872efec270d643dd2c281b6f245b03ff937/skimage/util/lazy.py).

## Discussion

At this point, there exists an prototype of lazy loading, and we're
showing it to the community to uncover design flaws, discover improvements, and solicit suggestions on APIs.

Once a lazy import interface is implemented, other interesting options become available.  For example, instead of specifying sub-submodules and functions the way we do above, one could do this in YAML files:

```
$ cat skimage/filters/init.yaml

submodules:
- rank

functions:
- _gaussian:
  - gaussian
  - difference_of_gaussians
- edges:
  - sobel
  - sobel_h
  - sobel_v
  - scharr

...
```

Ultimately, we hope that lazy importing will become part of Python
itself.  In the mean time, we now have the necessary mechanisms to
implement it ourselves.

## Notes

- The [lazy loading blog post by Brett Cannon](https://snarky.ca/lazy-importing-in-python-3-7/) showed the feasibility of the concept, and informed our design.

- Technical improvements happened around the [scikit-image PR](https://github.com/scikit-image/scikit-image/pull/5101)

- [mkinit](https://github.com/Erotemic/mkinit) is a tool that automates the generation of `__init__.py` files, and supports this lazy loading mechanism.  See, e.g., [NetworkX PR #4496](https://github.com/networkx/networkx/pull/4496).

- The lazy loading discussion was initiated in [NetworkX PR #4401](https://github.com/networkx/networkx/pull/4401).
